#!/usr/bin/python

# -*- Mode: python; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
# ex: set filetype=python softtabstop=4 shiftwidth=4 tabstop=4 expandtab:

#
# $Id: cisstTestMain.py.in 8 2009-01-04 21:13:48Z adeguet1 $
#

# Author: Andy LaMora, Anton Deguet
# Date: 2005-04-08

# (C) Copyright 2005-2007 Johns Hopkins University (JHU), All Rights
# Reserved.
 
# This file is processed automatically by CMake, if you need to modify
# it, modify the .in (input) processed by CMake

# --- begin cisst license - do not edit ---
# 
# This software is provided "as is" under an open source license, with
# no warranty.  The complete license can be found in license.txt and
# http://www.cisst.org/cisst/license.txt.
# 
# --- end cisst license ---

import unittest
import sys
import os
import getopt


module = '@LIB@'
pathTest =  '@cisstWrappingTests_SOURCE_DIR@'
pathTestCases = pathTest + "/" + module
pathLib = '@cisst_LIBRARY_PATH@/@config@'



sys.path.append(pathTestCases)
sys.path.append(pathLib)

verbose = False

# Load all the available tests from the source directory
ext  = '.py'
for filename in os.listdir(pathTestCases):
    if filename.endswith(ext):
        if verbose:
            print "Found python file", filename
        currentModuleName = os.path.splitext(filename)[0]
        command = "import " + currentModuleName
        exec command
    else:
        if verbose:
            print "Found non python file", filename




# Class to list all the tests based on the module, class and method to use
class TestInfo:
    classList = []
    def __init__( self ):
        self.Refresh()
    def Refresh( self ):
        for x in sys.modules:
            if verbose:
                print "Checking if", x, "contains any test case"
            if x.find("__") < 0 and x != "unittest":
                try:  # this is a cheap way of handling dir(x) failure (not a module)
                    content = eval("dir(" + x + ")")
                    for y in content:
                        if verbose:
                             print "Found", y, "in module", x
                        if y.find("__") < 0 and y != "unittest":
                             if issubclass(eval(x + "." + y), unittest.TestCase):
                                self.classList.append([x, y])
                                if verbose:
                                    print "Found test case", y, "in module", x
                                break
                except:
                    pass




# Print a somewhat accurate help message
def PrintHelp():
    print "cisst unit testing for python modules"
    print "Options:"
    print "   -h, --help:                    print this message"
    print "   -l, --list:                    list all tests for this library"
    print "   -r, --run:                     run all tests" 
    print "   -d <python>, --dart <python>:  like -l, but formated for CMake/ctest and requires full name of Python"
    print "   -t <test>, --test <test>:      run a specific test"
    print " "




# List all the tests in human readable format
def ListTests(prefix):
    tests = TestInfo()
    for x in tests.classList:
        moduleName = x[0]
        className = x[1]
        list = unittest.getTestCaseNames(eval(moduleName + "." + className) , prefix)
        for method in list:
            print moduleName + "." + className + "." + method
    return 0




# List all the tests formated for CMake/ctest
def ListTestsCMake(prefix, pythonExe):
    tests = TestInfo()
    for x in tests.classList: 
        moduleName = x[0]
        className = x[1]
        list = unittest.getTestCaseNames(eval(moduleName + "." + className) , prefix)
        programName = sys.argv[0]
        programName = programName.replace('\\', '/')
        for method in list:
            testName = className + "." + method
            print "ADD_TEST(\"Python: " + testName + "\" " + pythonExe + " " + programName + " -t " + moduleName + "." + testName + ")"
    return 0




# Run all tests
def RunAllTests(prefix):
    tests = TestInfo()
    
    result = unittest.TestResult()
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()
    
    for x in tests.classList: 
        moduleName = x[0]
        className = x[1]
        list = unittest.getTestCaseNames(eval(moduleName + "." + className) , prefix)
        for method in list:
            suite.addTest(loader.loadTestsFromName(method, eval(moduleName + "." + className)))
            
    suite.run(result)
    print result
    if not result.wasSuccessful():
        for i in range(len(result.errors)):
            print "!!!ERROR!!!"
            print str((result.errors[i])[0])
            print (result.errors[i])[1]
        for i in range( len(result.failures)):
            print "!!!FAILURE!!!"
            print str((result.failures[i])[0])
            print (result.failures[i])[1]
    else:
        print "successful"
    return 0




# Run one specific test specified in format module.class.method
def RunOneTest(testName):

    if len(testName)==0:
        print >>sys.stderr, "You need to provide an argument with -t"
        PrintHelp()
        return 1

    if testName.find(".") < 0:
        print "Missing test name"
        PrintHelp()
        return 1

    else:
        mod, cls, meth = testName.split(".")
        result = unittest.TestResult()
        loader = unittest.TestLoader()
        suite   = loader.loadTestsFromName(meth, eval(mod + "." + cls))
        print "Running test: " + mod + "." + cls + "." + meth
        suite.run(result)
        print result
        if not result.wasSuccessful():
            if len(result.errors) != 0:
                print "!!!ERRORS!!!"
                print str((result.errors[0])[0])
                print (result.errors[0])[1]
            if len(result.failures) != 0:
                print "!!!FAILURES!!!"
                print str((result.failures[0])[0])
                print (result.failures[0])[1]

            return 1
        else:
            print "OK (1 test)"
            return 0
        



def main(argv = None):
    prefix = "Test"

    if argv is None:
        argv = sys.argv

    try:
        opts, args = getopt.getopt(argv[1:], "hlrd:t:", ["help", "list", "run", "dart=", "test="])
    except getopt.GetoptError:
        print "Unknown option(s)"
        PrintHelp()
        return 1


    for option, argument in opts:
        if option in ("-h", "--help"):
            return PrintHelp()
        if option in ("-l", "--list"):
            return ListTests(prefix)
        if option in ("-r", "--run"):
            return RunAllTests(prefix)
        if option in ("-d", "--dart"):
            return ListTestsCMake(prefix, argument)
        if option in ("-t", "--test"):
            return RunOneTest(argument)
        
    print "No option provided"
    PrintHelp()
    return 1




# This is the main.  
# It should return to the shell the return value of main()
if __name__ == "__main__":
    sys.exit(main())



#
# $Log: cisstTestMain.py.in,v $
# Revision 1.14  2007/04/26 20:12:05  anton
# All files in tests: Applied new license text, separate copyright and
# updated dates, added standard header where missing.
#
# Revision 1.13  2006/11/20 20:33:53  anton
# Licensing: Applied new license to tests.
#
# Revision 1.12  2006/05/03 01:46:37  anton
# cisstTestMain.py.in: Added debug messages.
#
# Revision 1.11  2005/09/26 16:36:05  anton
# cisst: Added modelines for emacs and vi (python), see #164.
#
# Revision 1.10  2005/09/06 16:27:22  anton
# wrapping tests: Added license.
#
# Revision 1.9  2005/09/06 02:08:15  anton
# CMake configuration: Created a main CMakeLists.txt for the libs, tests and
# examples.  A lot of code has been "factorized" in the ./CMakeLists.txt.
# Known problems: "doc" is not working yet. Dependencies on SWIG projects don't
# work for parallel builds. If a lib is selected and then unselected, the tests
# still appear ...
#
# Revision 1.8  2005/07/15 15:23:28  anton
# cisstTestMain.py.in: Replace \ by / for CTest.
#
# Revision 1.7  2005/07/14 20:55:09  anton
# wrapping tests: Added code to define PYTHON_EXECUTABLE and use it for
# CTest.  This is required for Windows and should be safer for Unix.
#
# Revision 1.6  2005/07/14 04:00:56  anton
# cisst wrapping tests: Added code to handle release/debug configurations
# with MSVC.
#
# Revision 1.5  2005/07/01 03:26:15  anton
# cisstTestMain.py: Use issubclass instead of dirty hack using __bases__
#
# Revision 1.4  2005/06/23 14:51:10  anton
# cisstTestMain.py: Now display all errors and failures in RunAllTests.
#
# Revision 1.3  2005/06/23 14:35:05  anton
# cisstTestMain.py: Handle both errors and failures.  Added working RunAllTests.
#
# Revision 1.2  2005/06/14 17:38:42  anton
# Python wrapping tests: Major update based on Andy LaMora's work to integrate
# the Python tests with Dart2
#
# Revision 1.1  2005/04/08 16:37:24  anton
# Tests for Python wrapped libraries, creation.
#
