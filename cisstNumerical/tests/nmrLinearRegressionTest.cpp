/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-    */
/* ex: set filetype=cpp softtabstop=4 shiftwidth=4 tabstop=4 cindent expandtab: */

/*
  
  Author(s):  Peter Kazanzides
  Created on: 2016-04-29
  
  (C) Copyright 2016 Johns Hopkins University (JHU), All Rights Reserved.

--- begin cisst license - do not edit ---

This software is provided "as is" under an open source license, with
no warranty.  The complete license can be found in license.txt and
http://www.cisst.org/cisst/license.txt.

--- end cisst license ---
*/

#include <cisstVector/vctDynamicVectorTypes.h>

#include "nmrLinearRegressionTest.h"

// Following Y values generated by Y = 150*X + 25 + round(10*rand()-5),
// where X = 0..24 and rand() returns a random number between 0 and 1.
static int Y1[] = {21, 173, 323, 476, 630, 777, 921, 1078, 1224, 1378, 1528, 1673, 1829, 1971, 2125,
                   2273, 2427, 2570, 2721, 2872, 3020, 3172, 3328, 3479, 3620};
// Following ground-truth values computed by Excel (LINEST).
static double slope1 = 149.924615384615;
static double yint1 = 25.2646153846151;
static double mse1 = 10.3348923076932;

template <class _vectorType>
void nmrLinearRegressionTest::TestLinearRegression(void)
{
    typedef _vectorType::value_type ElementType;
    typedef nmrLinearRegressionSolver<ElementType>::SummationType SummationType;
    bool isIntegralType = (cmnTypeTraits<ElementType>::MinPositiveValue() == 1);
    ElementType tol = cmnTypeTraits<ElementType>::Tolerance();

    _vectorType x(20);
    _vectorType y(20);
    size_t i;
    ElementType slope, yint, mse;
    SummationType slope_num, yint_num, denom, tse_num;
    bool ret;

    // First, test with perfect data (no noise)
    for (i = 0; i < x.size(); i++) {
        x[i] = static_cast<ElementType>(i);
        y[i] = static_cast<ElementType>(i)*23 - 18;
    }
    ret = nmrLinearRegression(x, y, slope, yint, &mse);
    CPPUNIT_ASSERT(ret);
    if (isIntegralType) {
        CPPUNIT_ASSERT(slope == 23);
        CPPUNIT_ASSERT(yint == -18);
        CPPUNIT_ASSERT(mse == 0);
        nmrLinearRegressionSolver<ElementType> solver;
        CPPUNIT_ASSERT(solver.Sample(x,y));
        CPPUNIT_ASSERT(solver.EstimateAsFractions(slope_num, yint_num, denom, &tse_num));
        double slopef = static_cast<double>(slope_num)/static_cast<double>(denom);
        double yintf = static_cast<double>(yint_num)/static_cast<double>(denom);
        double msef = static_cast<double>(tse_num)/static_cast<double>(denom*solver.NumPoints());
        double tolf = cmnTypeTraits<double>::Tolerance();
        CPPUNIT_ASSERT((23-tolf <= slopef) && (slopef <= 23+tolf));
        CPPUNIT_ASSERT((-18-tolf <= yintf) && (yintf <= -18+tolf));
        CPPUNIT_ASSERT((-tolf <= msef) && (msef <= tolf));
    }
    else {
        CPPUNIT_ASSERT((23-tol <= slope) && (slope <= 23+tol));
        CPPUNIT_ASSERT((-18-tol <= yint) && (yint <= -18+tol));
        CPPUNIT_ASSERT((-tol <= mse) && (mse <= tol));
    }

    // Now, try with noisy data
    x.resize(sizeof(Y1)/sizeof(Y1[0]));
    y.resize(sizeof(Y1)/sizeof(Y1[0]));
    for (i = 0; i < x.size(); i++) {
        x[i] = static_cast<ElementType>(i);
        y[i] = static_cast<ElementType>(Y1[i]);
    }
    ret = nmrLinearRegression(x, y, slope, yint, &mse);
    CPPUNIT_ASSERT(ret);
    if (isIntegralType) {
        CPPUNIT_ASSERT(slope == static_cast<ElementType>(slope1));
        CPPUNIT_ASSERT(yint == static_cast<ElementType>(yint1));
        nmrLinearRegressionSolver<ElementType> solver;
        CPPUNIT_ASSERT(solver.Sample(x,y));
        CPPUNIT_ASSERT(solver.EstimateAsFractions(slope_num, yint_num, denom, &tse_num));
        double slopef = static_cast<double>(slope_num)/static_cast<double>(denom);
        double yintf = static_cast<double>(yint_num)/static_cast<double>(denom);
        double msef = static_cast<double>(tse_num)/static_cast<double>(denom*solver.NumPoints());;
        double tolf = cmnTypeTraits<double>::Tolerance();
        CPPUNIT_ASSERT((slope1-tolf <= slopef) && (slopef <= slope1+tolf));
        CPPUNIT_ASSERT((yint1-tolf <= yintf) && (yintf <= yint1+tolf));
        CPPUNIT_ASSERT((mse1-tolf <= msef) && (msef <= mse1+tolf));
    }
    else {
        CPPUNIT_ASSERT((slope1-tol <= slope) && (slope <= slope1+tol));
        CPPUNIT_ASSERT((yint1-tol <= yint) && (yint <= yint1+tol));
        CPPUNIT_ASSERT((mse1-tol <= mse) && (mse <= mse1+tol));
    }

    // Finally, verify that we detect vertical lines (infinite slope),
    // in which case nmrLinearRegression should return false.
    x.resize(10);
    y.resize(10);
    for (i = 0; i < x.size(); i++) {
        x[i] = static_cast<ElementType>(10);
        y[i] = static_cast<ElementType>(i);
    }
    ret = nmrLinearRegression(x, y, slope, yint, &mse);
    CPPUNIT_ASSERT(!ret);
    // Now test solver; Estimate should return false, whereas EstimateAsFractions
    // will work, but denom should be 0.
    nmrLinearRegressionSolver<ElementType> solver;
    CPPUNIT_ASSERT(solver.Sample(x,y));
    CPPUNIT_ASSERT(!solver.Estimate(slope,yint, &mse));
    CPPUNIT_ASSERT(solver.EstimateAsFractions(slope_num, yint_num, denom, &tse_num));
    if (isIntegralType)
        CPPUNIT_ASSERT(denom == 0);
    else
        CPPUNIT_ASSERT((-tol <= denom) && (denom <= tol));
}

void nmrLinearRegressionTest::TestLinearRegression_vctDoubleVec(void)
{
    TestLinearRegression<vctDoubleVec>();
}

void nmrLinearRegressionTest::TestLinearRegression_vctIntVec(void)
{
    TestLinearRegression<vctIntVec >();
}

void nmrLinearRegressionTest::TestLinearRegression_StdVecDouble(void)
{
    TestLinearRegression<std::vector<double> >();
}

void nmrLinearRegressionTest::TestLinearRegression_StdVecInt(void)
{
    TestLinearRegression<std::vector<int> >();
}

CPPUNIT_TEST_SUITE_REGISTRATION(nmrLinearRegressionTest);
